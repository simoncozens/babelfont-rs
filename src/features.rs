use crate::common::FormatSpecific;
use indexmap::IndexMap;
use serde::{Deserialize, Serialize};
use smol_str::SmolStr;
use typeshare::typeshare;

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[typeshare]
/// A wrapper for OpenType feature code that may be automatically generated.
pub struct PossiblyAutomaticCode {
    /// The feature code.
    pub code: String,
    /// Whether this code was automatically generated.
    /// If true, it may be regenerated by the application.
    #[serde(default, skip_serializing_if = "std::ops::Not::not")]
    pub automatic: bool,
    /// Format-specific data
    #[serde(default, skip_serializing_if = "FormatSpecific::is_empty")]
    #[typeshare(python(type = "Dict[str, Any]"))]
    #[typeshare(typescript(type = "Record<string, any>"))]
    pub format_specific: FormatSpecific,
}

impl PossiblyAutomaticCode {
    /// Create a new PossiblyAutomaticCode with the given code and automatic flag.
    pub fn new<S: Into<String>>(code: S) -> Self {
        Self {
            code: code.into(),
            automatic: false,
            format_specific: FormatSpecific::default(),
        }
    }
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[typeshare]
/// A representation of OpenType features, classes, and prefixes.
pub struct Features {
    /// Opentype classes
    ///
    /// The key should not start with @.
    #[typeshare(serialized_as = "HashMap<String, PossiblyAutomaticCode>")]
    pub classes: IndexMap<SmolStr, PossiblyAutomaticCode>,
    /// Opentype prefixes
    ///
    /// A dictionary of OpenType lookups and other feature code to be placed before features are defined.
    /// The keys are user-defined names, the values are AFDKO feature code.
    #[typeshare(serialized_as = "HashMap<String, PossiblyAutomaticCode>")]
    pub prefixes: IndexMap<SmolStr, PossiblyAutomaticCode>,
    /// OpenType features
    ///
    /// A list of OpenType feature code, expressed as a tuple (feature tag, code).
    #[typeshare(python(type = "List[Tuple[str, PossiblyAutomaticCode]]"))]
    #[typeshare(typescript(type = "Array<[string, PossiblyAutomaticCode]>"))]
    pub features: Vec<(SmolStr, PossiblyAutomaticCode)>,
    /// Include paths
    ///
    /// Paths to search for included feature files.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    #[typeshare(python(type = "List[str]"))]
    #[typeshare(typescript(type = "string[]"))]
    pub include_paths: Vec<std::path::PathBuf>,
}

impl Features {
    /// Serialize to a single string of AFDKO feature code.
    pub fn to_fea(&self) -> String {
        let mut fea = String::new();
        for (name, glyphs) in &self.classes {
            fea.push_str(&format!("@{} = [{}];\n", name, glyphs.code));
        }
        for (prefix, code) in &self.prefixes {
            if prefix != "anonymous" {
                fea.push_str(&format!("# Prefix: {}\n", prefix));
            }
            fea.push_str(&code.code);
            fea.push('\n');
        }
        for (name, code) in &self.features {
            fea.push_str(&format!(
                "feature {} {{\n{}\n}} {};\n",
                name, code.code, name
            ));
        }
        fea
    }

    /// A very naive parser that just puts everything into the anonymous prefix.
    pub fn from_fea(fea: &str) -> Features {
        let mut features = Features::default();
        features.prefixes.insert(
            "anonymous".into(),
            PossiblyAutomaticCode::new(fea.to_string()),
        );
        features
    }
}

#[cfg(feature = "glyphs")]
mod glyphs {
    use glyphslib::common::StylisticSetLabel;

    use crate::{features::PossiblyAutomaticCode, FormatSpecific};

    impl From<&glyphslib::common::FeatureClass> for PossiblyAutomaticCode {
        fn from(val: &glyphslib::common::FeatureClass) -> Self {
            let mut code = PossiblyAutomaticCode {
                code: val.code.clone(),
                automatic: val.automatic,
                format_specific: FormatSpecific::default(),
            };
            if val.disabled {
                code.format_specific.insert(
                    "com.schriftgestalt.Glyphs.disabled".into(),
                    serde_json::Value::Bool(true),
                );
            }
            if let Some(notes) = &val.notes {
                code.format_specific.insert(
                    "com.schriftgestalt.Glyphs.notes".into(),
                    serde_json::Value::String(notes.clone()),
                );
            }
            code
        }
    }

    impl From<&glyphslib::common::FeaturePrefix> for PossiblyAutomaticCode {
        fn from(val: &glyphslib::common::FeaturePrefix) -> Self {
            let mut code = PossiblyAutomaticCode {
                code: val.code.clone(),
                automatic: val.automatic,
                format_specific: FormatSpecific::default(),
            };
            if val.disabled {
                code.format_specific.insert(
                    "com.schriftgestalt.Glyphs.disabled".into(),
                    serde_json::Value::Bool(true),
                );
            }
            if let Some(notes) = &val.notes {
                code.format_specific.insert(
                    "com.schriftgestalt.Glyphs.notes".into(),
                    serde_json::Value::String(notes.clone()),
                );
            }
            code
        }
    }
    impl From<&glyphslib::common::Feature> for PossiblyAutomaticCode {
        fn from(val: &glyphslib::common::Feature) -> Self {
            let mut code = PossiblyAutomaticCode {
                code: val.code.clone(),
                automatic: val.automatic,
                format_specific: FormatSpecific::default(),
            };
            if val.disabled {
                code.format_specific.insert(
                    "com.schriftgestalt.Glyphs.disabled".into(),
                    serde_json::Value::Bool(true),
                );
            }
            if let Some(notes) = &val.notes {
                code.format_specific.insert(
                    "com.schriftgestalt.Glyphs.notes".into(),
                    serde_json::Value::String(notes.clone()),
                );
            }
            if !val.labels.is_empty() {
                let labels: Vec<serde_json::Value> = val
                    .labels
                    .iter()
                    .map(|label| {
                        let mut map = serde_json::Map::new();
                        map.insert(
                            "language".into(),
                            serde_json::Value::String(label.language.clone()),
                        );
                        map.insert(
                            "value".into(),
                            serde_json::Value::String(label.value.clone()),
                        );
                        serde_json::Value::Object(map)
                    })
                    .collect();
                code.format_specific.insert(
                    "com.schriftgestalt.Glyphs.labels".into(),
                    serde_json::Value::Array(labels),
                );
            }
            code
        }
    }

    // And back again

    impl PossiblyAutomaticCode {
        pub(crate) fn to_featureclass(&self, name: &str) -> glyphslib::common::FeatureClass {
            let disabled = self
                .format_specific
                .get("com.schriftgestalt.Glyphs.disabled")
                .and_then(|v| v.as_bool())
                .unwrap_or(false);
            let notes = self
                .format_specific
                .get("com.schriftgestalt.Glyphs.notes")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string());
            glyphslib::common::FeatureClass {
                code: self.code.clone(),
                automatic: self.automatic,
                disabled,
                notes,
                name: name.to_string(),
            }
        }

        pub(crate) fn to_featureprefix(&self, name: &str) -> glyphslib::common::FeaturePrefix {
            let disabled = self
                .format_specific
                .get("com.schriftgestalt.Glyphs.disabled")
                .and_then(|v| v.as_bool())
                .unwrap_or(false);
            let notes = self
                .format_specific
                .get("com.schriftgestalt.Glyphs.notes")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string());
            glyphslib::common::FeaturePrefix {
                code: self.code.clone(),
                automatic: self.automatic,
                disabled,
                notes,
                name: name.to_string(),
            }
        }

        pub(crate) fn to_feature(&self, name: &str) -> glyphslib::common::Feature {
            let disabled = self
                .format_specific
                .get("com.schriftgestalt.Glyphs.disabled")
                .and_then(|v| v.as_bool())
                .unwrap_or(false);
            let notes = self
                .format_specific
                .get("com.schriftgestalt.Glyphs.notes")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string());
            let labels = self
                .format_specific
                .get("com.schriftgestalt.Glyphs.labels")
                .and_then(|v| v.as_array())
                .map(|arr| {
                    arr.iter()
                        .map(|val| StylisticSetLabel {
                            language: val
                                .get("language")
                                .and_then(|v| v.as_str())
                                .unwrap_or("")
                                .to_string(),
                            value: val
                                .get("value")
                                .and_then(|v| v.as_str())
                                .unwrap_or("")
                                .to_string(),
                        })
                        .collect()
                })
                .unwrap_or_default();

            glyphslib::common::Feature {
                code: self.code.clone(),
                automatic: self.automatic,
                disabled,
                notes,
                tag: name.to_string(),
                labels,
            }
        }
    }
}
