/*
 Generated by typeshare 1.13.4
*/

/** A dictionary for internationalized strings. */
export type I18NDictionary = Record<string, string>;

/** An anchor point in a glyph */
export interface Anchor {
	/** X coordinate */
	x: number;
	/** Y coordinate */
	y: number;
	/** Name of the anchor */
	name?: string;
	/** Format-specific data */
	format_specific?: Record<string, any>;
}

/** An axis in a variable font */
export interface Axis {
	/** Name of the axis */
	name: I18NDictionary;
	/** 4-character tag of the axis */
	tag: string;
	/** Minimum value of the axis in user space coordinates */
	min?: import('@simoncozens/fonttypes').UserspaceCoordinate;
	/** Maximum value of the axis in user space coordinates */
	max?: import('@simoncozens/fonttypes').UserspaceCoordinate;
	/** Default value of the axis in user space coordinates */
	default?: import('@simoncozens/fonttypes').UserspaceCoordinate;
	/** Mapping of user space coordinates to design space coordinates */
	map?: Array<[import('@simoncozens/fonttypes').UserspaceCoordinate, import('@simoncozens/fonttypes').DesignspaceCoordinate]> | null;
	/** Whether the axis is hidden in the font's user interface */
	hidden?: boolean;
	/** Predefined values for the axis in user space coordinates */
	values?: import('@simoncozens/fonttypes').UserspaceCoordinate[];
	/** Format-specific data */
	formatspecific?: Record<string, any>;
}

export interface Color {
	r: number;
	g: number;
	b: number;
	a: number;
}

/** A component in a glyph */
export interface Component {
	/** The referenced glyph name */
	reference: string;
	/** The transformation applied to the component */
	transform: number[];
	/** Format-specific data */
	format_specific?: Record<string, any>;
}

/** A representation of OpenType features, classes, and prefixes. */
export interface Features {
	/**
	 * Opentype classes
	 * 
	 * The key should not start with @.
	 */
	classes: Record<string, string>;
	/**
	 * Opentype prefixes
	 * 
	 * A dictionary of OpenType lookups and other feature code to be placed before features are defined.
	 * The keys are user-defined names, the values are AFDKO feature code.
	 */
	prefixes: Record<string, string>;
	/**
	 * OpenType features
	 * 
	 * A list of OpenType feature code, expressed as a tuple (feature tag, code).
	 */
	features: Array<[string, string]>;
	/**
	 * Include paths
	 * 
	 * Paths to search for included feature files.
	 */
	include_paths?: string[];
}

/** Name table values for a font or individual master */
export interface Names {
	/** Copyright notice (OpenType Name ID 0) */
	copyright?: I18NDictionary;
	/** Font family name (OpenType Name ID 1) */
	family_name?: I18NDictionary;
	/** Font Subfamily name (OpenType Name ID 2) */
	preferred_subfamily_name?: I18NDictionary;
	/** Unique font identifier (OpenType Name ID 3) */
	unique_id?: I18NDictionary;
	/** Full font name (OpenType Name ID 4) */
	full_name?: I18NDictionary;
	/** Version string (OpenType Name ID 5) */
	version?: I18NDictionary;
	/** PostScript name for the font (OpenType Name ID 6) */
	postscript_name?: I18NDictionary;
	/** Trademark (OpenType Name ID 7) */
	trademark?: I18NDictionary;
	/** Manufacturer Name (OpenType Name ID 8) */
	manufacturer?: I18NDictionary;
	/** Designer. (Name of the designer of the typeface.) (OpenType Name ID 9) */
	designer?: I18NDictionary;
	/** Description. (Description of the typeface.) (OpenType Name ID 10) */
	description?: I18NDictionary;
	/** URL of Vendor. URL of font vendor (with protocol, e.g., http://, ftp://). (OpenType Name ID 11) */
	manufacturer_url?: I18NDictionary;
	/** URL of Designer. URL of typeface designer (with protocol, e.g., http://, ftp://). (OpenType Name ID 12) */
	designer_url?: I18NDictionary;
	/** License Description. Description of the license or licenses under which the font is provided. (OpenType Name ID 13) */
	license?: I18NDictionary;
	/** License Info URL. URL where additional licensing information can be found. (OpenType Name ID 14) */
	license_url?: I18NDictionary;
	/** Typographic Family name. (OpenType Name ID 16) */
	typographic_family?: I18NDictionary;
	/** Typographic Subfamily name. (OpenType Name ID 17) */
	typographic_subfamily?: I18NDictionary;
	/** Compatible Full (Macintosh only). (OpenType Name ID 18) */
	compatible_full_name?: I18NDictionary;
	/** Sample text. (OpenType Name ID 19) */
	sample_text?: I18NDictionary;
	/** PostScript CID findfont name. (OpenType Name ID 20) */
	postscript_cid_name?: I18NDictionary;
	/** WWS Family Name. (OpenType Name ID 21) */
	wws_family_name?: I18NDictionary;
	/** WWS Subfamily Name. (OpenType Name ID 22) */
	wws_subfamily_name?: I18NDictionary;
	/** Variations PostScript Name Prefix. (OpenType Name ID 25) */
	variations_postscript_name_prefix?: I18NDictionary;
}

/** A font instance */
export interface Instance {
	/**
	 * Unique identifier for the instance
	 * 
	 * Should be unique within the design space; usually a UUID.
	 */
	id: string;
	/** Name of the instance */
	name: I18NDictionary;
	/** Location of the instance in design space coordinates */
	location?: import('@simoncozens/fonttypes').DesignspaceLocation;
	/** Any custom names for the instance if it is exported as a static font */
	custom_names: Names;
	/** Whether the instance represents an export of a variable font */
	variable?: boolean;
	/** Name of the linked style for style linking (e.g., "Bold Italic" links to "Bold" and "Italic") */
	linked_style?: string;
	/** Format-specific data */
	format_specific?: Record<string, any>;
}

/** A position in 2D space, with an optional angle */
export interface Position {
	/** X coordinate */
	x: number;
	/** Y coordinate */
	y: number;
	/** Angle in degrees */
	angle?: number;
}

/** A guideline in the font, whether at master or layer level */
export interface Guide {
	/** Position of the guideline */
	pos: Position;
	/** Optional name of the guideline */
	name?: string;
	/** Optional color of the guideline */
	color?: Color;
	/** Format-specific data */
	format_specific?: Record<string, any>;
}

/** A scalar value in an OpenType table */
export type OTScalar = 
	/** String value */
	| { type: "StringType", content: string }
	/** Boolean value */
	| { type: "Bool", content: boolean }
	/** Unsigned integer value */
	| { type: "Unsigned", content: number }
	/** Signed integer value */
	| { type: "Signed", content: number }
	/** Floating-point value */
	| { type: "Float", content: number }
	/** Bit field value */
	| { type: "BitField", content: number[] }
	/** Array of floating-point values */
	| { type: "Array", content: number[] };

export interface OTValue {
	table: string;
	field: string;
	value: OTScalar;
}

/** A master/source font in a design space */
export interface Master {
	/** Name of the master */
	name: I18NDictionary;
	/** Unique identifier for the master (usually a UUID) */
	id: string;
	/** Location of the master in design space coordinates */
	location?: import('@simoncozens/fonttypes').DesignspaceLocation;
	/** Global guidelines associated with the master */
	guides?: Guide[];
	/** Master-specific metrics */
	metrics: Record<string, number>;
	/**
	 * Kerning for this master.
	 * 
	 * (Kerning pairs are (left glyph name, right glyph name) -> value)
	 * Groups are represented as `@<groupname>`; whether they are first or second
	 * groups is determined by position in the tuple.
	 */
	kerning: Map<[string, string], number>;
	/** Custom OpenType values for this master */
	custom_ot_values?: OTValue[];
	/** Format-specific data */
	format_specific?: Record<string, any>;
}

/** The category of a glyph */
export enum GlyphCategory {
	/** A base glyph */
	Base = "Base",
	/** A mark glyph */
	Mark = "Mark",
	/** An unknown / un-set category */
	Unknown = "Unknown",
	/** A ligature glyph */
	Ligature = "Ligature",
}

/** The type of a layer in relation to masters */
export type LayerType = 
	/** A default layer for a master */
	| { type: "DefaultForMaster", master: string }
	/** A layer associated with a master but not the default */
	| { type: "AssociatedWithMaster", master: string }
	/** A free-floating layer not associated with any master */
	| { type: "FreeFloating", master?: undefined };

/** A shape in a glyph, either a component or a path */
export type Shape = 
	/** A component in a glyph */
	| Component
	/** A path in a glyph */
	| Path;

/** A layer of a glyph in a font */
export interface Layer {
	/** The advance width of the layer */
	width: number;
	/** The name of the layer */
	name?: string;
	/** The ID of the layer */
	id?: string;
	/** The relationship between this layer and a master, if any */
	master?: LayerType;
	/** Guidelines in the layer */
	guides?: Guide[];
	/** Shapes (paths and components) in the layer */
	shapes?: Shape[];
	/** Anchors in the layer */
	anchors?: Anchor[];
	/** The color of the layer */
	color?: Color;
	/** The index of the layer in a color font */
	layer_index?: number;
	/** Whether this layer is a background layer */
	is_background?: boolean;
	/** The ID of the background layer for this layer, if any */
	background_layer_id?: string;
	/** The location of the layer in design space, if it is not at the default location for a master */
	location?: import('@simoncozens/fonttypes').DesignspaceLocation;
	/** Format-specific data for the layer */
	format_specific?: Record<string, any>;
}

/** Direction of text flow */
export enum Direction {
	/** Left to right text flow */
	LeftToRight = "LeftToRight",
	/** Right to left text flow */
	RightToLeft = "RightToLeft",
	/** Top to bottom text flow */
	TopToBottom = "TopToBottom",
}

/** A glyph in the font */
export interface Glyph {
	/** The name of the glyph */
	name: string;
	/** The production name of the glyph, if any */
	production_name?: string;
	/** The category of the glyph */
	category: GlyphCategory;
	/** Unicode codepoints assigned to the glyph */
	codepoints?: number[];
	/**
	 * The layers in the glyph
	 * 
	 * These include background layers, design-only layers, etc. as well as
	 * the main master and location-specific layers.
	 */
	layers?: Layer[];
	/** Whether the glyph is exported */
	exported: boolean;
	/** The writing direction of the glyph, if any */
	direction?: Direction;
	/** Format-specific data */
	formatspecific?: Record<string, any>;
}

/** A representation of a font source file */
export interface Font {
	/** Units per em */
	upm: number;
	/** Font version as (major, minor) */
	version: [number, number];
	/**
	 * A list of axes, in the case of variable/multiple master font.
	 * 
	 * May be empty.
	 */
	axes?: Axis[];
	/** A list of named/static instances */
	instances?: Instance[];
	/** A list of the font's masters */
	masters?: Master[];
	/** A list of the font's glyphs */
	glyphs: Glyph[];
	/** An optional note about the font */
	note?: string;
	/** The font's creation date */
	date: Date;
	/** The font's naming information */
	names: Names;
	/**
	 * Any values to be placed in OpenType tables on export to override defaults
	 * 
	 * These must be font-wide. Metrics which may vary by master should be placed in the `metrics` field of a Master
	 */
	custom_ot_values?: OTValue[];
	/** A map of Unicode Variation Sequences to glyph names */
	variation_sequences?: Record<string, string>;
	/** A representation of the font's OpenType features */
	features: Features;
	/**
	 * A dictionary of kerning groups
	 * 
	 * The key is the group name and the value is a list of glyph names in the group
	 * Group names are *not* prefixed with "@" here
	 */
	first_kern_groups?: Record<string, string[]>;
	/**
	 * 
	 * The key is the group name and the value is a list of glyph names in the group
	 * Group names are *not* prefixed with "@" here
	 */
	second_kern_groups?: Record<string, string[]>;
	/** Format-specific data */
	format_specific?: Record<string, any>;
	/** The source file path, if any, from which this font was loaded */
	source?: string;
}

/** Types of nodes in a glyph outline */
export enum NodeType {
	/** Move to a new position without drawing (only defined for open contours) */
	Move = "Move",
	/** Draw a straight line to this node */
	Line = "Line",
	/** Cubic Bézier curve control node (off-curve) */
	OffCurve = "OffCurve",
	/** Draw a cubic Bézier curve to this node */
	Curve = "Curve",
	/** Draw a quadratic Bézier curve to this node */
	QCurve = "QCurve",
}

/** A node in a glyph outline */
export interface Node {
	/** The x-coordinate of the node */
	x: number;
	/** The y-coordinate of the node */
	y: number;
	/** The type of the node */
	nodetype: NodeType;
	/** Whether the node is smooth */
	smooth?: boolean;
}

/** A path in a glyph */
export interface Path {
	/** A list of nodes in the path */
	nodes: Node[];
	/** Whether the path is closed */
	closed: boolean;
	/** Format-specific data */
	format_specific?: Record<string, any>;
}

/** Type of font metric */
export type MetricType = 
	/** X height */
	| "XHeight"
	/** Cap height */
	| "CapHeight"
	/** Ascender (design-time ascender for the master) */
	| "Ascender"
	/** Descender (design-time descender for the master) */
	| "Descender"
	/** Italic angle (in degrees, negative for right slant) */
	| "ItalicAngle"
	/** Ascender (to be placed in the `hhea` table) */
	| "HheaAscender"
	/** Descender (to be placed in the `hhea` table) */
	| "HheaDescender"
	/** Line gap (to be placed in the `hhea` table) */
	| "HheaLineGap"
	/** Windows Ascender (to be placed in the `OS/2` table) */
	| "WinAscent"
	/** Windows Descender (to be placed in the `OS/2` table) */
	| "WinDescent"
	/** Typographic Ascender (to be placed in the `OS/2` table) */
	| "TypoAscender"
	/** Typographic Descender (to be placed in the `OS/2` table) */
	| "TypoDescender"
	/** Typographic Line Gap (to be placed in the `OS/2` table) */
	| "TypoLineGap"
	/** Subscript horizontal font size */
	| "SubscriptXSize"
	/** Subscript vertical font size */
	| "SubscriptYSize"
	/** Subscript horizontal offset */
	| "SubscriptXOffset"
	/** Subscript vertical offset */
	| "SubscriptYOffset"
	/** Superscript horizontal font size */
	| "SuperscriptXSize"
	/** Superscript vertical font size */
	| "SuperscriptYSize"
	/** Superscript horizontal offset */
	| "SuperscriptXOffset"
	/** Superscript vertical offset */
	| "SuperscriptYOffset"
	/** Strikeout size */
	| "StrikeoutSize"
	/** Strikeout position */
	| "StrikeoutPosition"
	/** Underline position */
	| "UnderlinePosition"
	/** Underline thickness */
	| "UnderlineThickness"
	/** Caret slope rise (for the `hhea` table) */
	| "HheaCaretSlopeRise"
	/** Caret slope run (for the `hhea` table) */
	| "HheaCaretSlopeRun"
	/** Caret offset (for the `hhea` table) */
	| "HheaCaretOffset"
	/** Custom metric type */
	| { "Custom": string };

/** The style map style of a font */
export enum StyleMapStyle {
	/** Bold italic style */
	BoldItalic = "BoldItalic",
	/** Bold style */
	Bold = "Bold",
	/** Regular style */
	Regular = "Regular",
	/** Italic style */
	Italic = "Italic",
}

/**
 * Custom JSON reviver and replacer functions for dynamic data transformation
 * ReviverFunc is used during JSON parsing to detect and transform specific data structures
 * ReplacerFunc is used during JSON serialization to modify certain values before stringifying.
 * These functions allow for flexible encoding and decoding of data, ensuring that complex types are properly handled when converting between TS objects and JSON
 */
export const ReviverFunc = (key: string, value: unknown): unknown => {
    if (typeof value === "string" && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/.test(value) && (key === "date")) {
        return new Date(value);
    }
    return value;
};

export const ReplacerFunc = (key: string, value: unknown): unknown => {
    if (value instanceof Date) {
        return value.toISOString();
    }
    return value;
};
